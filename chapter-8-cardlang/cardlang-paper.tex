\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}

\geometry{margin=1in}

% Code listing styles
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.5,0}
\definecolor{codepurple}{rgb}{0.5,0,0.5}

\lstdefinestyle{haskell}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    keywordstyle=\color{codepurple}\bfseries,
    commentstyle=\color{codegreen},
    stringstyle=\color{blue},
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray},
    keywords={data, type, deriving, where, let, in, if, then, else, case, of, class, instance}
}

\lstdefinestyle{yaml}{
    backgroundcolor=\color{codebg},
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny\color{gray}
}

% Theorem environments
\newtheorem{definition}{Definition}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{property}{Property}[section]

\title{\textbf{CardLang}: A Domain-Specific Language for\\Formally Specified Card Games}

\author{
    Lucas\\
    \texttt{lucas@example.com}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We present \textsc{CardLang}, a domain-specific language (DSL) for the formal specification of card games. By treating fundamental card game concepts---\texttt{Card}, \texttt{Rank}, \texttt{Suit}, and \texttt{Deck}---as language primitives, we enable game definitions that are both human-readable and mathematically precise. Our functional approach, inspired by Haskell, allows deck definitions to be expressed as composable expressions over primitive types. The compiler generates verified implementations of core operations, including deterministic shuffling via Fisher-Yates with cryptographic seeding, enabling applications in provably fair gaming systems and blockchain-based card games. We demonstrate the expressiveness of \textsc{CardLang} through the specification of games ranging from simple cut-for-high-card to complex variants, and discuss integration with commitment schemes for trustless multiplayer execution.
\end{abstract}

\section{Introduction}

Card games represent one of humanity's oldest forms of structured entertainment, with a rich history spanning cultures and centuries. Despite this ubiquity, no standard formalism exists for precisely specifying the rules, mechanics, and valid states of card games. Existing implementations are typically ad-hoc, mixing game logic with presentation concerns and lacking verifiable correctness properties.

The emergence of online gaming platforms and blockchain-based casinos has created new demands for card game specifications that are deterministic, verifiable, and auditable. When real value is at stake, players require guarantees that the deck was fairly shuffled, that game rules are applied consistently, and that outcomes can be independently verified.

We present \textsc{CardLang}, a domain-specific language designed to address these challenges. Our key contributions are:

\begin{enumerate}
    \item \textbf{Primitive Types}: A minimal set of primitive types (\texttt{Rank}, \texttt{Suit}, \texttt{Card}, \texttt{Deck}) that capture the essential structure of card games.
    
    \item \textbf{Functional Deck Definitions}: A compositional approach to deck construction using higher-order combinators, allowing complex deck types to be derived from simple expressions.
    
    \item \textbf{Deterministic Operations}: Formally specified algorithms for shuffling and other operations, parameterized by cryptographic seeds for reproducibility.
    
    \item \textbf{Game Specification Grammar}: A declarative syntax for specifying game rules, phases, and victory conditions.
    
    \item \textbf{Verified Compilation}: A compiler that generates correct-by-construction implementations of specified games.
\end{enumerate}

\section{Related Work}

Game description languages have been explored in several contexts. The Game Description Language (GDL) \cite{love2008general} provides a logic-based formalism for general game playing, but lacks domain-specific primitives for card games. Poker-specific formalisms exist \cite{billings2002challenge} but do not generalize to other card games.

In the functional programming community, domain-specific languages embedded in Haskell have proven effective for capturing domain semantics while leveraging the host language's type system \cite{hudak1996building}. Our approach draws inspiration from this tradition.

The cryptographic requirements for fair card games have been studied extensively in the context of mental poker \cite{shamir1981mental}, providing the theoretical foundation for our deterministic shuffling primitives.

\section{Primitive Types}

The foundation of \textsc{CardLang} consists of four primitive types that capture the essential structure of playing cards.

\begin{definition}[Rank]
A \texttt{Rank} is an enumerated type representing the face value of a card:
\begin{lstlisting}[style=haskell]
data Rank = R2 | R3 | R4 | R5 | R6 | R7 | R8 | R9 
          | RT | RJ | RQ | RK | RA
    deriving (Eq, Enum, Bounded)
\end{lstlisting}
The set of ranks is denoted $\mathcal{R} = \{2, 3, 4, 5, 6, 7, 8, 9, T, J, Q, K, A\}$ with $|\mathcal{R}| = 13$.
\end{definition}

\begin{definition}[Suit]
A \texttt{Suit} is an enumerated type representing the suit of a card:
\begin{lstlisting}[style=haskell]
data Suit = Clubs | Diamonds | Hearts | Spades
    deriving (Eq, Enum, Bounded)
\end{lstlisting}
The set of suits is denoted $\mathcal{S} = \{\clubsuit, \diamondsuit, \heartsuit, \spadesuit\}$ with $|\mathcal{S}| = 4$.
\end{definition}

\begin{definition}[Card]
A \texttt{Card} is a product type of \texttt{Rank} and \texttt{Suit}:
\begin{lstlisting}[style=haskell]
data Card = Card Rank Suit
    deriving (Eq)
\end{lstlisting}
The set of standard cards is $\mathcal{C} = \mathcal{R} \times \mathcal{S}$ with $|\mathcal{C}| = 52$.
\end{definition}

\begin{definition}[Deck]
A \texttt{Deck} is an ordered sequence of cards:
\begin{lstlisting}[style=haskell]
type Deck = [Card]
\end{lstlisting}
A deck $D$ is a sequence $(c_0, c_1, \ldots, c_{n-1})$ where each $c_i \in \mathcal{C}$.
\end{definition}

\subsection{Byte Encoding}

For efficient runtime representation and cryptographic operations, cards are encoded as single bytes.

\begin{definition}[Card Encoding]
Given a canonical deck definition $D = (c_0, c_1, \ldots, c_{n-1})$, the encoding function $\texttt{encode}_D : \mathcal{C} \to \mathbb{B}$ maps each card to its index:
\[
\texttt{encode}_D(c) = i \text{ where } c = c_i
\]
For the standard 52-card deck with the canonical ordering (clubs, diamonds, hearts, spades) $\times$ (2 through A):
\[
\texttt{encode}(\texttt{Card } r\ s) = \texttt{fromEnum}(r) + \texttt{fromEnum}(s) \times 13
\]
\end{definition}

This yields the mapping: $2\clubsuit \mapsto 0$, $3\clubsuit \mapsto 1$, \ldots, $A\clubsuit \mapsto 12$, $2\diamondsuit \mapsto 13$, \ldots, $A\spadesuit \mapsto 51$.

\section{Deck Definitions as Expressions}

A key insight of \textsc{CardLang} is that deck definitions can be expressed as pure functions over the primitive types. This enables composition, verification, and reuse.

\subsection{The Standard 52-Card Deck}

\begin{lstlisting}[style=haskell]
standard52 :: Deck
standard52 = [Card r s | s <- [Clubs ..], r <- [R2 ..]]
\end{lstlisting}

The list comprehension generates the Cartesian product $\mathcal{R} \times \mathcal{S}$ in canonical order.

\subsection{Deck Combinators}

We define higher-order functions for constructing decks:

\begin{lstlisting}[style=haskell]
-- Build deck from predicates
deckWhere :: (Rank -> Bool) -> (Suit -> Bool) -> Deck
deckWhere rankP suitP = 
    [Card r s | s <- filter suitP [Clubs ..]
              , r <- filter rankP [R2 ..]]

-- Add jokers to any deck
withJokers :: Int -> Deck -> Deck
withJokers n deck = deck ++ replicate n Joker

-- Duplicate cards (for Pinochle, etc.)
duplicated :: Int -> Deck -> Deck
duplicated n = concatMap (replicate n)

-- Filter a deck
restricted :: (Card -> Bool) -> Deck -> Deck
restricted = filter
\end{lstlisting}

\subsection{Example Deck Definitions}

Using these combinators, common deck variants become concise expressions:

\begin{lstlisting}[style=haskell]
-- Euchre: 9 through A (24 cards)
euchre :: Deck
euchre = deckWhere (>= R9) (const True)

-- Pinochle: 9 through A, doubled (48 cards)
pinochle :: Deck
pinochle = duplicated 2 $ deckWhere (>= R9) (const True)

-- 500 deck: complex filtering plus joker
fiveHundred :: Deck
fiveHundred = redCards ++ blackCards ++ [Card R4 Hearts, Card R4 Diamonds, Joker]
  where
    redCards   = deckWhere (>= R7) (`elem` [Hearts, Diamonds])
    blackCards = deckWhere (>= R5) (`elem` [Spades, Clubs])
\end{lstlisting}

\begin{property}[Deck Cardinality]
For any deck definition $D$ constructed via combinators, $|D|$ is statically computable at compile time.
\end{property}

\section{Deterministic Shuffling}

For applications requiring verifiability, shuffling must be deterministic given a seed. We specify the Fisher-Yates shuffle with cryptographic random number generation.

\subsection{Fisher-Yates Algorithm}

\begin{algorithm}
\caption{Fisher-Yates Shuffle}
\begin{algorithmic}[1]
\Require Deck $D = [c_0, c_1, \ldots, c_{n-1}]$, seed $s \in \{0,1\}^{256}$
\Ensure Permuted deck $D'$
\State Initialize RNG with seed $s$
\For{$i = n-1$ downto $1$}
    \State $j \leftarrow \texttt{random}(0, i)$ \Comment{Uniform in $[0, i]$}
    \State Swap $D[i]$ and $D[j]$
\EndFor
\State \Return $D$
\end{algorithmic}
\end{algorithm}

\begin{definition}[Shuffle Primitive]
\begin{lstlisting}[style=haskell]
shuffle :: Seed -> Deck -> Deck
shuffle seed deck = fisherYates (initRng seed) deck
  where
    initRng :: Seed -> ChaCha20
    fisherYates :: ChaCha20 -> Deck -> Deck
\end{lstlisting}
\end{definition}

\subsection{Seed Generation for Multiplayer}

In adversarial multiplayer settings, the seed must be generated via a commitment scheme to prevent manipulation.

\begin{definition}[Commitment-Based Seed]
For $n$ players, the combined seed is generated as:
\begin{enumerate}
    \item Each player $i$ generates random $s_i \in \{0,1\}^{256}$
    \item Each player broadcasts commitment $h_i = H(s_i)$
    \item After all commitments received, players reveal $s_i$
    \item Verify $H(s_i) = h_i$ for all $i$
    \item Combined seed: $s = H(s_1 \| s_2 \| \cdots \| s_n)$
\end{enumerate}
\end{definition}

\begin{lstlisting}[style=haskell]
type Seed = ByteString  -- 32 bytes
type Commitment = ByteString  -- SHA256 hash

data SeedProtocol = SeedProtocol
    { commit :: Seed -> Commitment
    , reveal :: Seed -> Commitment -> Bool  
    , combine :: [Seed] -> Seed
    }

defaultProtocol :: SeedProtocol
defaultProtocol = SeedProtocol
    { commit  = sha256
    , reveal  = \s c -> sha256 s == c
    , combine = sha256 . mconcat
    }
\end{lstlisting}

\begin{theorem}[Shuffle Fairness]
Given the commitment-based seed generation protocol, no coalition of fewer than $n$ players can predict or influence the shuffle outcome, assuming the hash function $H$ is a random oracle.
\end{theorem}

\section{The Draw Primitive}

The \texttt{draw} operation is the fundamental state transition in card games, moving cards from one zone to another. We formalize it as a pure function with explicit preconditions and postconditions.

\subsection{Zones and Game State}

Cards exist in \emph{zones}---distinct regions with different visibility and ownership properties.

\begin{definition}[Zone]
A \texttt{Zone} is a named, ordered collection of cards:
\begin{lstlisting}[style=haskell]
data ZoneType = DeckZone      -- face down, no owner
              | HandZone      -- hidden, owned by player
              | CommunityZone -- face up, shared
              | DiscardZone   -- face up, no owner
              | BurnZone      -- face down, out of play
    deriving (Eq, Show)

data Zone = Zone
    { zoneId    :: ZoneId
    , zoneType  :: ZoneType
    , zoneCards :: [Card]
    , zoneOwner :: Maybe PlayerId
    }
\end{lstlisting}
\end{definition}

\begin{definition}[Game State]
The game state $\Gamma$ is a mapping from zone identifiers to zones:
\begin{lstlisting}[style=haskell]
type GameState = Map ZoneId Zone
\end{lstlisting}
We write $\Gamma(z)$ for the cards in zone $z$, and $|\Gamma(z)|$ for the count.
\end{definition}

\subsection{Draw as a Pure Function}

\begin{definition}[Draw]
The \texttt{draw} function transfers $n$ cards from a source zone to a destination zone:
\begin{lstlisting}[style=haskell]
draw :: Int -> ZoneId -> ZoneId -> GameState -> Either DrawError GameState
draw n src dst state
    | n <= 0              = Left (InvalidCount n)
    | n > length srcCards = Left (InsufficientCards src n (length srcCards))
    | otherwise           = Right state'
  where
    srcCards      = zoneCards (state ! src)
    (drawn, rest) = splitAt n srcCards
    state'        = state 
                  & ix src . zoneCards .~ rest
                  & ix dst . zoneCards %~ (++ drawn)
\end{lstlisting}
\end{definition}

The type signature makes explicit that \texttt{draw} may fail, returning a \texttt{DrawError} in the \texttt{Left} case.

\begin{lstlisting}[style=haskell]
data DrawError 
    = InvalidCount Int
    | InsufficientCards ZoneId Int Int  -- zone, requested, available
    | ZoneNotFound ZoneId
    | CardNotInZone Card ZoneId
    deriving (Eq, Show)
\end{lstlisting}

\subsection{Formal Specification}

We specify \texttt{draw} via preconditions, postconditions, and invariants.

\begin{definition}[Draw Preconditions]
For $\texttt{draw}(n, src, dst, \Gamma)$ to succeed:
\begin{align}
    n &> 0 \tag{P1: positive count} \\
    n &\leq |\Gamma(src)| \tag{P2: sufficient cards} \\
    src &\in \text{dom}(\Gamma) \tag{P3: source exists} \\
    dst &\in \text{dom}(\Gamma) \tag{P4: destination exists}
\end{align}
\end{definition}

\begin{definition}[Draw Postconditions]
If $\Gamma' = \texttt{draw}(n, src, dst, \Gamma)$ succeeds, then:
\begin{align}
    |\Gamma'(src)| &= |\Gamma(src)| - n \tag{Q1: source shrinks} \\
    |\Gamma'(dst)| &= |\Gamma(dst)| + n \tag{Q2: destination grows} \\
    \Gamma'(src) &= \texttt{drop } n\ \Gamma(src) \tag{Q3: first $n$ removed} \\
    \texttt{take } n\ \Gamma(src) &\subseteq \Gamma'(dst) \tag{Q4: cards transferred}
\end{align}
\end{definition}

\begin{theorem}[Card Conservation]
The \texttt{draw} operation preserves the total card count:
\[
\sum_{z \in \text{dom}(\Gamma)} |\Gamma(z)| = \sum_{z \in \text{dom}(\Gamma')} |\Gamma'(z)|
\]
\end{theorem}

\begin{proof}
By Q1 and Q2, the source loses exactly $n$ cards and the destination gains exactly $n$ cards. All other zones are unchanged. Thus the total is preserved.
\end{proof}

\begin{theorem}[Card Identity Preservation]
The multiset of all cards across all zones is invariant under \texttt{draw}:
\[
\biguplus_{z \in \text{dom}(\Gamma)} \Gamma(z) = \biguplus_{z \in \text{dom}(\Gamma')} \Gamma'(z)
\]
\end{theorem}

\begin{proof}
The cards removed from $src$ are exactly the cards added to $dst$; no cards are created or destroyed.
\end{proof}

\subsection{Draw Variants}

Several common operations are defined in terms of the base \texttt{draw}:

\begin{lstlisting}[style=haskell]
-- Draw a single card
draw1 :: ZoneId -> ZoneId -> GameState -> Either DrawError (Card, GameState)
draw1 src dst state = do
    state' <- draw 1 src dst state
    let card = head $ zoneCards (state ! src)  -- safe: draw succeeded
    return (card, state')

-- Draw from bottom of deck
drawBottom :: Int -> ZoneId -> ZoneId -> GameState -> Either DrawError GameState
drawBottom n src dst state
    | n > length srcCards = Left (InsufficientCards src n (length srcCards))
    | otherwise           = Right state'
  where
    srcCards        = zoneCards (state ! src)
    (rest, drawn)   = splitAt (length srcCards - n) srcCards
    state'          = state
                    & ix src . zoneCards .~ rest
                    & ix dst . zoneCards %~ (++ drawn)

-- Draw specific card (for games with choice)
drawCard :: Card -> ZoneId -> ZoneId -> GameState -> Either DrawError GameState
drawCard card src dst state
    | card `notElem` srcCards = Left (CardNotInZone card src)
    | otherwise               = Right state'
  where
    srcCards = zoneCards (state ! src)
    state'   = state
             & ix src . zoneCards %~ delete card
             & ix dst . zoneCards %~ (++ [card])

-- Draw all cards
drawAll :: ZoneId -> ZoneId -> GameState -> GameState
drawAll src dst state = state
    & ix dst . zoneCards %~ (++ srcCards)
    & ix src . zoneCards .~ []
  where
    srcCards = zoneCards (state ! src)
\end{lstlisting}

\subsection{Indexed Draw for Verifiability}

For cryptographic verification, we track not just the resulting state but also the exact operation performed:

\begin{lstlisting}[style=haskell]
data DrawRecord = DrawRecord
    { drCount   :: Int
    , drSource  :: ZoneId
    , drDest    :: ZoneId
    , drCards   :: [Card]      -- which cards moved
    , drIndices :: [Int]       -- their positions in source
    } deriving (Eq, Show)

drawWithRecord :: Int -> ZoneId -> ZoneId -> GameState 
               -> Either DrawError (GameState, DrawRecord)
drawWithRecord n src dst state = do
    state' <- draw n src dst state
    let srcCards = zoneCards (state ! src)
        drawn    = take n srcCards
        record   = DrawRecord n src dst drawn [0..n-1]
    return (state', record)
\end{lstlisting}

The \texttt{DrawRecord} provides an audit trail: given the prior state and the record, anyone can verify the transition and reconstruct the new state.

\subsection{Composition: The Deal Operation}

The \texttt{deal} operation is repeated \texttt{draw} to multiple destinations:

\begin{lstlisting}[style=haskell]
-- Deal n cards to each player in order
deal :: Int -> ZoneId -> [ZoneId] -> GameState -> Either DrawError GameState
deal n src dsts = foldM dealOne
  where
    dealOne state dst = draw n src dst state

-- Deal one card at a time, rotating through players (standard dealing)
dealRound :: Int -> ZoneId -> [ZoneId] -> GameState -> Either DrawError GameState
dealRound rounds src dsts state = foldM dealOne state (concat $ replicate rounds dsts)
  where
    dealOne st dst = draw 1 src dst st
\end{lstlisting}

\begin{lstlisting}[style=yaml]
# In game specification syntax:
setup:
  - deal: 2 to each_player from deck    # dealRound 2 deck players
  - deal: 5 to community from deck      # draw 5 deck community
\end{lstlisting}

\begin{property}[Deal Determinism]
Given the same initial deck state (post-shuffle) and player order, \texttt{deal} produces identical hands regardless of implementation, as it is defined purely in terms of \texttt{draw}.
\end{property}

\section{Deck Manipulation Primitives}

Beyond \texttt{draw}, several operations manipulate deck structure without transferring cards between zones. We formalize these as pure functions with verifiable properties.

\subsection{Cut}

The \texttt{cut} operation splits a deck at position $k$ and transposes the two halves. This is a standard anti-cheating measure in physical card games.

\begin{definition}[Cut]
For a deck $D = (c_0, c_1, \ldots, c_{n-1})$ and cut position $k \in [0, n]$:
\[
\texttt{cut}(k, D) = (c_k, c_{k+1}, \ldots, c_{n-1}, c_0, c_1, \ldots, c_{k-1})
\]
\end{definition}

\begin{lstlisting}[style=haskell]
cut :: Int -> ZoneId -> GameState -> Either CutError GameState
cut k zone state
    | k < 0           = Left (InvalidCutPosition k)
    | k > length cards = Left (InvalidCutPosition k)
    | otherwise       = Right $ state & ix zone . zoneCards .~ cut'
  where
    cards        = zoneCards (state ! zone)
    (top, bottom) = splitAt k cards
    cut'         = bottom ++ top

data CutError = InvalidCutPosition Int
              | ZoneNotFound ZoneId
    deriving (Eq, Show)
\end{lstlisting}

\begin{property}[Cut is a Rotation]
The cut operation is equivalent to a left rotation by $k$ positions:
\[
\texttt{cut}(k, D) = \texttt{rotate}_L(k, D)
\]
\end{property}

\begin{theorem}[Cut Preserves Cards]
For any valid cut position $k$:
\[
\texttt{multiset}(\texttt{cut}(k, D)) = \texttt{multiset}(D)
\]
The cut operation is a permutation; no cards are created, destroyed, or duplicated.
\end{theorem}

\begin{theorem}[Cut Inverse]
Cutting is self-inverse with complementary position:
\[
\texttt{cut}(n - k, \texttt{cut}(k, D)) = D
\]
\end{theorem}

\subsubsection{Deterministic Cut Selection}

In a verifiable system, the cut position itself must be determined fairly. We define a seeded cut:

\begin{lstlisting}[style=haskell]
cutWithSeed :: Seed -> ZoneId -> GameState -> GameState
cutWithSeed seed zone state = 
    let cards = zoneCards (state ! zone)
        n     = length cards
        k     = bytesToInt seed `mod` n  -- uniform in [0, n-1]
    in fromRight state $ cut k zone state

-- For player-selected cuts with commitment
data CutCommitment = CutCommitment
    { cutPlayer   :: PlayerId
    , cutHash     :: Hash        -- H(position || salt)
    , cutPosition :: Maybe Int   -- revealed after commitment
    , cutSalt     :: Maybe Salt
    }
\end{lstlisting}

\subsection{Burn}

The \texttt{burn} operation discards cards face-down, removing them from play without revealing their values. This prevents exploitation of marked cards or deck tracking.

\begin{definition}[Burn]
Burning $n$ cards transfers them from the source zone to the burn zone:
\[
\texttt{burn}(n, src, \Gamma) = \texttt{draw}(n, src, \texttt{burnZone}, \Gamma)
\]
\end{definition}

\begin{lstlisting}[style=haskell]
burn :: Int -> ZoneId -> GameState -> Either DrawError GameState
burn n src = draw n src burnZone
  where
    burnZone = ZoneId "burn"

-- Burn with record for verification
burnWithRecord :: Int -> ZoneId -> GameState 
               -> Either DrawError (GameState, BurnRecord)
burnWithRecord n src state = do
    (state', drawRec) <- drawWithRecord n src burnZone state
    let burnRec = BurnRecord
            { brCount  = n
            , brSource = src
            , brCards  = drCards drawRec  -- hidden in practice, revealed for verification
            }
    return (state', burnRec)

data BurnRecord = BurnRecord
    { brCount  :: Int
    , brSource :: ZoneId
    , brCards  :: [Card]  -- for post-hoc verification only
    } deriving (Eq, Show)
\end{lstlisting}

\begin{property}[Burn Semantics]
Burned cards are:
\begin{enumerate}
    \item Removed from the source zone
    \item Not revealed to any player during normal play
    \item Verifiable post-game via the burn record
    \item Not recyclable (unlike discard)
\end{enumerate}
\end{property}

\subsection{Discard}

The \texttt{discard} operation moves cards to a discard pile, which unlike the burn pile may be recycled back into the deck. Discards may be either face-up (visible to all) or face-down (hidden).

\begin{definition}[Visibility]
Card visibility is a property of the zone and the discard action:
\begin{lstlisting}[style=haskell]
data Visibility = FaceUp | FaceDown
    deriving (Eq, Show)

data DiscardZone = DiscardZone
    { dzId         :: ZoneId
    , dzCards      :: [Card]
    , dzVisibility :: [(Card, Visibility)]  -- per-card visibility
    }
\end{lstlisting}
\end{definition}

\begin{definition}[Discard]
Discarding $n$ cards transfers them from source to the discard zone with specified visibility:
\[
\texttt{discard}(n, v, src, \Gamma) = (\Gamma', R)
\]
where $\Gamma'$ is the updated game state and $R$ is the discard record.
\end{definition}

\begin{lstlisting}[style=haskell]
discard :: Int -> Visibility -> ZoneId -> GameState 
        -> Either DiscardError GameState
discard n vis src state
    | n <= 0              = Left (InvalidDiscardCount n)
    | n > length srcCards = Left (InsufficientCards src n (length srcCards))
    | otherwise           = Right state'
  where
    srcCards          = zoneCards (state ! src)
    (discarded, rest) = splitAt n srcCards
    discardZone       = state ! discardZoneId
    newVisibility     = dzVisibility discardZone ++ map (, vis) discarded
    state'            = state
                      & ix src . zoneCards .~ rest
                      & ix discardZoneId . dzCards %~ (++ discarded)
                      & ix discardZoneId . dzVisibility .~ newVisibility

data DiscardError
    = InvalidDiscardCount Int
    | InsufficientCards ZoneId Int Int
    | DiscardZoneNotFound
    deriving (Eq, Show)
\end{lstlisting}

\subsubsection{Face-Up Discard}

Face-up discards are visible to all players. This is common in games like Rummy, where players may draw from the discard pile.

\begin{lstlisting}[style=haskell]
discardFaceUp :: Int -> ZoneId -> GameState -> Either DiscardError GameState
discardFaceUp n = discard n FaceUp

-- Discard specific cards face-up (player choice)
discardCards :: [Card] -> Visibility -> ZoneId -> GameState 
             -> Either DiscardError GameState
discardCards cards vis src state
    | not (all (`elem` srcCards) cards) = Left CardNotInZone
    | otherwise = Right state'
  where
    srcCards    = zoneCards (state ! src)
    state'      = state
                & ix src . zoneCards %~ (\\ cards)
                & ix discardZoneId . dzCards %~ (++ cards)
                & ix discardZoneId . dzVisibility %~ (++ map (, vis) cards)
\end{lstlisting}

\begin{definition}[Face-Up Discard Postconditions]
After $\texttt{discardFaceUp}(n, src, \Gamma) = \Gamma'$:
\begin{align}
    \forall c \in \texttt{discarded} : \texttt{visible}(c, \Gamma') &= \texttt{AllPlayers} \tag{D1} \\
    \texttt{topCard}(\Gamma'(\texttt{discard})) &= \texttt{last}(\texttt{discarded}) \tag{D2}
\end{align}
\end{definition}

\subsubsection{Face-Down Discard}

Face-down discards hide the card values. This is used when a player mucks (folds) in poker without revealing.

\begin{lstlisting}[style=haskell]
discardFaceDown :: Int -> ZoneId -> GameState -> Either DiscardError GameState
discardFaceDown n = discard n FaceDown

-- Muck: discard entire hand face-down (poker fold)
muck :: ZoneId -> GameState -> GameState
muck hand state = fromRight state $ discard n FaceDown hand state
  where
    n = length $ zoneCards (state ! hand)
\end{lstlisting}

\begin{definition}[Face-Down Discard Postconditions]
After $\texttt{discardFaceDown}(n, src, \Gamma) = \Gamma'$:
\begin{align}
    \forall c \in \texttt{discarded} : \texttt{visible}(c, \Gamma') &= \emptyset \tag{D3} \\
    \texttt{identity}(c) \text{ recoverable only from } &\texttt{DiscardRecord} \tag{D4}
\end{align}
\end{definition}

\subsubsection{Discard with Record}

For verifiable games, we track full discard history:

\begin{lstlisting}[style=haskell]
data DiscardRecord = DiscardRecord
    { drTimestamp  :: Int              -- action sequence number
    , drPlayer     :: Maybe PlayerId   -- who discarded (if applicable)
    , drSource     :: ZoneId
    , drCards      :: [Card]
    , drVisibility :: Visibility
    , drIndices    :: [Int]            -- original positions in source
    } deriving (Eq, Show)

discardWithRecord :: Int -> Visibility -> ZoneId -> GameState
                  -> Either DiscardError (GameState, DiscardRecord)
discardWithRecord n vis src state = do
    state' <- discard n vis src state
    let srcCards = zoneCards (state ! src)
        record   = DiscardRecord
            { drTimestamp  = actionCount state
            , drPlayer     = zoneOwner (state ! src)
            , drSource     = src
            , drCards      = take n srcCards
            , drVisibility = vis
            , drIndices    = [0..n-1]
            }
    return (state', record)
\end{lstlisting}

\subsubsection{Discard vs Burn}

The key distinction between discard and burn:

\begin{table}[h]
\centering
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{Property} & \textbf{Discard} & \textbf{Burn} \\
\midrule
Visibility options & Face-up or face-down & Always face-down \\
Recyclable & Yes (reshuffle) & No \\
Drawable & Yes (some games) & Never \\
Destination zone & Discard pile & Burn pile \\
Typical use & Played/folded cards & Anti-cheat mechanism \\
\bottomrule
\end{tabular}
\caption{Comparison of discard and burn operations.}
\label{tab:discard-burn}
\end{table}

\subsection{Recycle}

The \texttt{recycle} operation returns discarded cards to the deck, typically followed by a shuffle:

\begin{lstlisting}[style=haskell]
recycle :: ZoneId -> GameState -> GameState
recycle discardZone state = state
    & ix deckZone . zoneCards %~ (++ discardedCards)
    & ix discardZone . dzCards .~ []
    & ix discardZone . dzVisibility .~ []
  where
    discardedCards = dzCards (state ! discardZone)

-- Full recycle with shuffle
recycleAndShuffle :: Seed -> ZoneId -> GameState -> GameState
recycleAndShuffle seed discardZone state = 
    state & recycle discardZone & shuffle seed deckZone
\end{lstlisting}

\begin{lstlisting}[style=yaml]
# In CardLang DSL:
on_deck_empty:
  - recycle: discard_pile into deck
  - shuffle: deck with new_seed
  - burn: 1 from deck
\end{lstlisting}

\begin{theorem}[Recycle Preserves Cards]
The recycle operation preserves the card multiset:
\[
\texttt{multiset}(\Gamma(\texttt{deck})) \uplus \texttt{multiset}(\Gamma(\texttt{discard})) = \texttt{multiset}(\Gamma'(\texttt{deck}))
\]
where $\Gamma' = \texttt{recycle}(\texttt{discard}, \Gamma)$.
\end{theorem}

\subsection{Riffle and Wash}

For completeness, we define additional physical shuffling operations that may appear in game specifications.

\begin{definition}[Riffle Shuffle]
A riffle shuffle interleaves two halves of the deck. Given deck $D$ split at midpoint into $L$ and $R$:
\[
\texttt{riffle}(D) = \texttt{interleave}(L, R)
\]
where \texttt{interleave} alternates cards from each half.
\end{definition}

\begin{lstlisting}[style=haskell]
riffle :: ZoneId -> GameState -> GameState
riffle zone state = state & ix zone . zoneCards .~ riffled
  where
    cards         = zoneCards (state ! zone)
    (left, right) = splitAt (length cards `div` 2) cards
    riffled       = interleave left right
    
interleave :: [a] -> [a] -> [a]
interleave []     ys = ys
interleave xs     [] = xs
interleave (x:xs) (y:ys) = x : y : interleave xs ys

-- Seeded riffle with realistic imperfection
riffleWithSeed :: Seed -> ZoneId -> GameState -> GameState
riffleWithSeed seed zone state = state & ix zone . zoneCards .~ riffled
  where
    cards  = zoneCards (state ! zone)
    rng    = initRng seed
    riffled = simulateRiffle rng cards
    
    -- Models imperfect human riffle: variable packet sizes
    simulateRiffle :: RNG -> [Card] -> [Card]
\end{lstlisting}

\begin{definition}[Wash / Scramble]
A wash (or scramble) spreads cards face-down and mixes them randomly. This is modeled as a Fisher-Yates shuffle:
\[
\texttt{wash}(seed, D) = \texttt{shuffle}(seed, D)
\]
\end{definition}

\begin{lstlisting}[style=haskell]
wash :: Seed -> ZoneId -> GameState -> GameState
wash seed zone state = state & ix zone . zoneCards .~ washed
  where
    cards  = zoneCards (state ! zone)
    washed = fisherYates (initRng seed) cards
\end{lstlisting}

\subsection{Strip Cut}

A strip cut removes packets from the top and reassembles them in a different order.

\begin{definition}[Strip Cut]
Given packet sizes $(p_1, p_2, \ldots, p_m)$ summing to $n$, and a permutation $\sigma$ of $[1..m]$:
\[
\texttt{stripCut}((p_1, \ldots, p_m), \sigma, D) = P_{\sigma(1)} \mathbin{+\!\!\!+} P_{\sigma(2)} \mathbin{+\!\!\!+} \cdots \mathbin{+\!\!\!+} P_{\sigma(m)}
\]
where $P_i$ is the $i$-th packet of size $p_i$.
\end{definition}

\begin{lstlisting}[style=haskell]
stripCut :: [Int] -> [Int] -> ZoneId -> GameState -> Either StripError GameState
stripCut packetSizes ordering zone state
    | sum packetSizes /= length cards = Left InvalidPacketSizes
    | sort ordering /= [0..length packetSizes - 1] = Left InvalidOrdering
    | otherwise = Right $ state & ix zone . zoneCards .~ stripped
  where
    cards    = zoneCards (state ! zone)
    packets  = splitIntoPackets packetSizes cards
    stripped = concatMap (packets !!) ordering

splitIntoPackets :: [Int] -> [a] -> [[a]]
splitIntoPackets [] _ = []
splitIntoPackets (p:ps) xs = 
    let (packet, rest) = splitAt p xs
    in packet : splitIntoPackets ps rest

data StripError = InvalidPacketSizes | InvalidOrdering
    deriving (Eq, Show)
\end{lstlisting}

\subsection{Combine and Split}

Operations for merging and dividing card collections.

\begin{lstlisting}[style=haskell]
-- Combine multiple zones into one (e.g., collecting cards for reshuffle)
combine :: [ZoneId] -> ZoneId -> GameState -> GameState
combine srcs dst state = foldr collectFrom state srcs
  where
    collectFrom src st = fromRight st $ drawAll src dst st

-- Split a zone into multiple zones (e.g., dealing to separate hands)
split :: ZoneId -> [(ZoneId, Int)] -> GameState -> Either DrawError GameState
split src distributions = foldM distribute
  where
    distribute state (dst, n) = draw n src dst state
\end{lstlisting}

\subsection{Operation Composition}

Complex dealing procedures are compositions of primitives:

\begin{lstlisting}[style=haskell]
-- Standard casino poker dealing procedure
casinoDeal :: Seed -> [PlayerId] -> GameState -> GameState
casinoDeal seed players state = state
    & execState (do
        -- Wash and riffle
        modify $ wash seed1 deckZone
        modify $ riffle deckZone
        modify $ riffle deckZone
        modify $ riffle deckZone
        
        -- Player cut
        modify $ cutWithSeed seed2 deckZone
        
        -- Burn and deal
        modify $ fromRight id . burn 1 deckZone
        forM_ [1..2] $ \_ ->
            forM_ players $ \p ->
                modify $ fromRight id . draw 1 deckZone (handZone p)
      )
  where
    (seed1, seed2) = splitSeed seed
\end{lstlisting}

\begin{lstlisting}[style=yaml]
# Equivalent in CardLang DSL:
dealing_procedure: casino_standard
  
setup:
  - wash: deck with seed
  - riffle: deck times 3
  - cut: deck by player
  - burn: 1 from deck
  - deal: 2 to each_player from deck
\end{lstlisting}

\subsection{Summary of Deck Operations}

\begin{table}[h]
\centering
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Operation} & \textbf{Signature} & \textbf{Effect} \\
\midrule
\texttt{shuffle} & $Seed \to Zone \to \Gamma \to \Gamma$ & Random permutation \\
\texttt{cut} & $Int \to Zone \to \Gamma \to \Gamma$ & Rotate at position \\
\texttt{burn} & $Int \to Zone \to \Gamma \to \Gamma$ & Discard face-down \\
\texttt{riffle} & $Zone \to \Gamma \to \Gamma$ & Interleave halves \\
\texttt{wash} & $Seed \to Zone \to \Gamma \to \Gamma$ & Spread and scramble \\
\texttt{stripCut} & $[Int] \to [Int] \to Zone \to \Gamma \to \Gamma$ & Packet reorder \\
\texttt{combine} & $[Zone] \to Zone \to \Gamma \to \Gamma$ & Merge zones \\
\texttt{draw} & $Int \to Zone \to Zone \to \Gamma \to \Gamma$ & Transfer cards \\
\bottomrule
\end{tabular}
\caption{Deck manipulation primitives and their type signatures.}
\label{tab:deck-ops}
\end{table}

\begin{theorem}[Composition Closure]
All deck manipulation primitives preserve card conservation: the multiset of cards across all zones is invariant under any sequence of operations.
\end{theorem}

\section{Ranking Systems}

Different games impose different orderings on cards. We capture this via the \texttt{Ranking} type class.

\begin{lstlisting}[style=haskell]
class Ranking a where
    compareCards :: a -> Card -> Card -> Ordering
    
data HighCardRanking = HighCardRanking
    { aceHigh :: Bool
    , suitOrder :: Maybe [Suit]  -- Nothing = suits don't break ties
    }

instance Ranking HighCardRanking where
    compareCards cfg c1 c2 = 
        case compare (rankValue cfg $ rank c1) (rankValue cfg $ rank c2) of
            EQ -> compareSuits cfg (suit c1) (suit c2)
            x  -> x
\end{lstlisting}

\section{Game Specification}

Games are specified declaratively, describing components, setup, rounds, and victory conditions.

\subsection{Cut for High Card}

We present the complete specification for the simplest non-trivial card game:

\begin{lstlisting}[style=yaml]
game: cut_for_high_card
version: 1.0

components:
  deck: standard_52
  
ranking:
  type: high_card
  ace: high
  suits_break_ties: false

players:
  count: 2..8

setup:
  - shuffle: deck

round:
  name: cut
  
  actions:
    - each_player:
        - draw: 1 from deck -> hand
        - reveal: hand
  
  resolve:
    compare: players.hand using ranking
    winner: highest
    
  on_tie:
    - reshuffle: revealed cards into deck
    - repeat: round

victory:
  condition: win_round
  award: pot
\end{lstlisting}

\subsection{Compilation Target}

The \textsc{CardLang} compiler transforms this specification into executable code with the following properties:

\begin{enumerate}
    \item \textbf{State Machine}: The game becomes a finite state machine with well-defined transitions.
    \item \textbf{Verified Operations}: \texttt{shuffle} compiles to Fisher-Yates; \texttt{compare} uses the specified ranking.
    \item \textbf{Determinism}: Given initial state and seed, all outcomes are reproducible.
    \item \textbf{Audit Trail}: Every state transition is logged for verification.
\end{enumerate}

\section{Extended Example: Texas Hold'em}

To demonstrate the expressiveness of \textsc{CardLang}, we sketch the specification for Texas Hold'em poker:

\begin{lstlisting}[style=yaml]
game: texas_holdem
version: 1.0

components:
  deck: standard_52
  
ranking:
  type: poker_hand
  ace: high_and_low  # for straights
  
players:
  count: 2..10
  
positions:
  - dealer: rotates
  - small_blind: dealer + 1
  - big_blind: dealer + 2

setup:
  - shuffle: deck
  - post: small_blind -> pot
  - post: big_blind -> pot
  - deal: 2 to each_player -> hand (hidden)

rounds:
  - name: preflop
    betting: standard
    
  - name: flop
    actions:
      - burn: 1 from deck
      - deal: 3 from deck -> community (revealed)
    betting: standard
    
  - name: turn
    actions:
      - burn: 1 from deck  
      - deal: 1 from deck -> community (revealed)
    betting: standard
    
  - name: river
    actions:
      - burn: 1 from deck
      - deal: 1 from deck -> community (revealed)
    betting: standard

showdown:
  evaluate: best_5_of_7(hand + community) using ranking
  winner: highest
  award: pot
  
  on_tie:
    split: pot among tied_players
\end{lstlisting}

\section{Implementation Considerations}

\subsection{Blockchain Integration}

\textsc{CardLang} specifications are suitable for smart contract deployment:

\begin{itemize}
    \item Deterministic shuffling enables on-chain verification
    \item State machine representation maps naturally to contract storage
    \item Commitment schemes integrate with blockchain transaction ordering
\end{itemize}

\subsection{Byte-Level Efficiency}

The byte encoding of cards enables efficient operations:

\begin{lstlisting}[style=haskell]
-- Deck as byte array
type DeckBytes = ByteString  -- length = deck cardinality

-- Shuffle operates on bytes directly
shuffleBytes :: Seed -> DeckBytes -> DeckBytes
\end{lstlisting}

\section{Future Work}

Several extensions are planned for \textsc{CardLang}:

\begin{enumerate}
    \item \textbf{Formal Verification}: Integration with proof assistants (Coq, Agda) to verify game properties.
    
    \item \textbf{Multi-Deck Games}: Support for games requiring multiple decks (Canasta, Blackjack shoes).
    
    \item \textbf{Hidden Information}: Formal treatment of information asymmetry and player knowledge.
    
    \item \textbf{Betting Primitives}: First-class support for pot management, betting rounds, and side pots.
    
    \item \textbf{Tournament Structures}: Specifications for multi-table tournaments and elimination formats.
\end{enumerate}

\section{Conclusion}

We have presented \textsc{CardLang}, a domain-specific language for formally specifying card games. By elevating card game concepts to language primitives and adopting a functional approach to deck construction, we enable specifications that are simultaneously human-readable, mathematically precise, and suitable for verified implementation.

The deterministic shuffling primitive, combined with cryptographic commitment schemes, addresses the requirements of provably fair gaming systems. The compilation to efficient byte-level representations enables deployment in resource-constrained environments including blockchain smart contracts.

\textsc{CardLang} demonstrates that domain-specific languages can capture the semantics of traditional games while enabling new applications in verifiable computing.

\bibliographystyle{plain}
\begin{thebibliography}{9}

\bibitem{love2008general}
Love, N., Hinrichs, T., Haley, D., Schkufza, E., \& Genesereth, M. (2008).
General Game Playing: Game Description Language Specification.
\textit{Stanford Logic Group Technical Report LG-2006-01}.

\bibitem{billings2002challenge}
Billings, D., Davidson, A., Schaeffer, J., \& Szafron, D. (2002).
The challenge of poker.
\textit{Artificial Intelligence}, 134(1-2), 201-240.

\bibitem{hudak1996building}
Hudak, P. (1996).
Building domain-specific embedded languages.
\textit{ACM Computing Surveys}, 28(4es), 196-es.

\bibitem{shamir1981mental}
Shamir, A., Rivest, R. L., \& Adleman, L. M. (1981).
Mental Poker.
\textit{The Mathematical Gardner}, 37-43.

\bibitem{knuth1997art}
Knuth, D. E. (1997).
\textit{The Art of Computer Programming, Volume 2: Seminumerical Algorithms}.
Addison-Wesley, 3rd edition.

\bibitem{goldreich2001foundations}
Goldreich, O. (2001).
\textit{Foundations of Cryptography: Basic Tools}.
Cambridge University Press.

\end{thebibliography}

\end{document}
